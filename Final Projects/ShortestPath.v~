`timescale 1 ns/1 ns
`define MAX 2048
`define SIZE_ROW 4
`define D_WIDTH 8
`define A_WIDTH 4

module ShortestPath(Go, Clk, Rst, L_In, M_In, L_Out, P_Out, M_Addr, L_Addr, P_Addr, 
				M_En, M_Rw, L_En, L_Rw, P_En, P_Rw, Done);

	input Go;
	input Clk, Rst;
	input [(`D_WIDTH - 1):0] L_In, M_In;
	output reg [(`D_WIDTH - 1):0] L_Out;
	output reg [(`D_WIDTH - 1):0] P_Out;
	output reg [(`A_WIDTH - 1):0] M_Addr, L_Addr, P_Addr;
	output reg M_En, M_Rw, L_En, L_Rw, P_En, P_Rw, Done;

	
	reg [(`D_WIDTH - 1):0] M_Reg, L_Reg, L_Temp_Reg;
	reg [4:0] State;
	integer I, J, Addr0, Addr1, Addr2;

	parameter S0 = 5'b00000, S1 = 5'b00001, S2 = 5'b00010, S3 = 5'b10011,
		  S3a = 5'b00011, S3b = 5'b00100, S3c = 5'b00101,
		  S4a = 5'b00110, S4b = 5'b00111, S4c = 5'b01000, S4d = 5'b01001, 
		  S5a = 5'b01010, S5b = 5'b01011, S5c = 5'b01100, S5d = 5'b01101,
		  S6a = 5'b01110, S6b = 5'b01111, S6c = 5'b10000, S6d = 5'b10001, S7 = 5'b10010;
	parameter Start = 4'b0000, Right = 4'b0001, Down = 4'b0010;

	always @(posedge Clk) begin
		if(Rst == 1) begin
			// output regs
			L_Out <= {`D_WIDTH{1'b0}}; 
			P_Out <= {`D_WIDTH{1'b0}};
			M_Addr <= {`A_WIDTH{1'b0}};
			L_Addr <= {`A_WIDTH{1'b0}};
			P_Addr <= {`A_WIDTH{1'b0}};
			M_En <= 1'b0;
			M_Rw <= 1'b0;
			L_En <= 1'b0;
			L_Rw <= 1'b0;
			P_En <= 1'b0;
			P_Rw <= 1'b0;
			Done <= 1'b0;
			// internal reg
			M_Reg <= {`D_WIDTH - 1{1'b0}};
			L_Reg <= {`D_WIDTH - 1{1'b0}};
			L_Temp_Reg <={`D_WIDTH - 1{1'b0}};
			State <= S0;
			I <= 0;
			J <= 0;
			Addr0 <= 0;
			Addr1 <= 0;
			Addr2 <= 0;
		end
		else begin
			// outputs
			L_Out <= {`D_WIDTH{1'b0}}; 
			P_Out <= {`D_WIDTH{1'b0}};
			M_Addr <= {`A_WIDTH{1'b0}};
			L_Addr <= {`A_WIDTH{1'b0}};
			P_Addr <= {`A_WIDTH{1'b0}};
			M_En <= 1'b0;
			M_Rw <= 1'b0;
			L_En <= 1'b0;
			L_Rw <= 1'b0;
			P_En <= 1'b0;
			P_Rw <= 1'b0;
			Done <= 1'b0;
			
			case(State)
				// Initial State
				S0: begin
					if(Go == 1'b1) begin
						State <= S1;
					end
					else begin
						State <= S0;
					end
				end
				// I loop
				S1: begin
					// J loop starts
					if(I < `SIZE_ROW) begin
						J <= 0;
						State <= S2;
					end
					else begin
					// algorithm ended
						Done <= 1'b1;
						State <= S0;
					end
				end
				S2: begin
					// Inside of J loop
					if(J < `SIZE_ROW) begin
						Addr0 <= I * `SIZE_ROW + J;
						Addr1 <= (I - 1) * `SIZE_ROW + J;
						Addr2 <= I * `SIZE_ROW + (J - 1);
						State <= S3;
					end
					else begin
						I = I + 1;
						State <= S1;
					end
				end
				S3: begin
					if(I == 0 && J == 0) begin
						// prepare to write output memory P
						P_Out <= Start;
						P_En <= 1'b1;
						P_Rw <= 1'b1; // write P
						P_Addr <= Addr0;
						// prepare to read input memory M
						M_En <= 1'b1;
						M_Rw <= 1'b0; // read M	
						M_Addr <= Addr0;				
						State <= S3a;
					end
					else if(I == 0) begin
						// prepare to write output memory P
						P_Out <= Right;
						P_En <= 1'b1;
						P_Rw <= 1'b1; // write P
						P_Addr <= Addr0;
						// prepare to read input memory M
						M_En <= 1'b1;
						M_Rw <= 1'b0; // read M	
						M_Addr <= Addr0;				
						// prepare to read in/out memory L
						L_En <= 1'b1;
						L_Rw <= 1'b0; // read L
						L_Addr <= Addr2;				
						State <= S4a;
					end
					else if(J == 0) begin
						// prepare to write output memory P
						P_Out <= Down;
						P_En <= 1'b1;
						P_Rw <= 1'b1; // write P
						P_Addr <= Addr0;
						// prepare to read input memory M
						M_En <= 1'b1;
						M_Rw <= 1'b0; // read M	
						M_Addr <= Addr0;				
						// prepare to read in/out memory L
						L_En <= 1'b1;
						L_Rw <= 1'b0; // read L
						L_Addr <= Addr1;				
						State <= S5a;	
					end
					else begin
						// prepare to read in/out memory L
						L_En <= 1'b1;
						L_Rw <= 1'b0; // read L
						L_Addr <= Addr1;				
						State <= S6a;		
					end
				end
				// i == 0 && j == 0
				S3a: begin
					// input memory M will be ready in one state
					State <= S3b;	
				end
				S3b: begin
					// M_reg will be ready in one state
					M_Reg <= M_In;	
					State <= S3c;
				end
				S3c: begin
					// prepare to write in/out memory L
					L_Out <= M_Reg;
					L_En <= 1'b1;
					L_Rw <= 1'b1; // write L
					L_Addr <= Addr0;
					// plus J by 1
					J = J + 1;
					State <= S2;
				end
				// i == 0
				S4a: begin
					// output memory P will be ready in one state
					// input memory M will be ready in one state
					// in/out memory L will be ready in one state
					State <= S4b;		
				end
				S4b: begin
					M_Reg <= M_In;	
					L_Reg <= L_In;
					State <= S4c;	
				end
				S4c: begin
					// M_reg and L_reg will be ready in one state
					State <= S4d;
				end
				S4d: begin
					// prepare to write in/out memory L
					L_Out <= M_Reg + L_Reg;
					L_En <= 1'b1;
					L_Rw <= 1'b1; // write L
					L_Addr <= Addr0;
					// plus J by 1
					J = J + 1;
					State <= S2;
				end
				// j == o
				S5a: begin
					// output memory P will be ready in one state
					// input memory M will be ready in one state
					// in/out memory L will be ready in one state
					State <= S5b;		
				end
				S5b: begin
					M_Reg <= M_In;	
					L_Reg <= L_In;
					State <= S5c;	
				end
				S5c: begin
					// M_reg and L_reg will be ready in one state
					State <= S5d;
				end
				S5d: begin
					// prepare to write in/out memory L
					L_Out <= M_Reg + L_Reg;
					L_En <= 1'b1;
					L_Rw <= 1'b1; // write L
					L_Addr <= Addr0;
					// plus J by 1
					J = J + 1;
					State <= S2;
				end
				// else : preparation
				S6a: begin
					// in/out memory L will be ready in one state	
					State <= S6b;	
				end
				S6b: begin
					L_Reg <= L_In;
					// prepare to read in/out memory L
					L_En <= 1'b1;
					L_Rw <= 1'b0; // read L
					L_Addr <= Addr2;				
					State <= S6c;		
				end
				S6c: begin
					// in/out memory L will be ready in one state
					State <= S6d;
				end
				S6d: begin
					L_Temp_Reg <= L_In;
					State <= S7;
				end
				// else : starts
				S7: begin
					if(L_Reg < L_Temp_Reg) begin
						// prepare to write output memory P
						P_Out <= Down;
						P_En <= 1'b1;
						P_Rw <= 1'b1; // write P
						P_Addr <= Addr0;
						// prepare to read input memory M
						M_En <= 1'b1;
						M_Rw <= 1'b0; // read M	
						M_Addr <= Addr0;				
						// prepare to read in/out memory L
						L_En <= 1'b1;
						L_Rw <= 1'b0; // read L
						L_Addr <= Addr1;				
						State <= S5a;	
					end
					else begin
						// prepare to write output memory P
						P_Out <= Right;
						P_En <= 1'b1;
						P_Rw <= 1'b1; // write P
						P_Addr <= Addr0;
						// prepare to read input memory M
						M_En <= 1'b1;
						M_Rw <= 1'b0; // read M	
						M_Addr <= Addr0;				
						// prepare to read in/out memory L
						L_En <= 1'b1;
						L_Rw <= 1'b0; // read L
						L_Addr <= Addr2;				
						State <= S4a;
					end
				end
			endcase
		end
	end
	
endmodule 
